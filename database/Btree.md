## B tree （2-3 tree）https://www.cs.usfca.edu/~galles/visualization/BTree.html

### important demo

**删除**

- 当删除键可能导致节点键数少于最小键数时，节点可以从相邻兄弟节点借键或与一个兄弟节点合并。
- 删除操作也可能导致多层的节点合并和键的重新分配，以保持所有节点的最小键数。

一个例子

       [5,          10]
     /       |         \
    [3]      [7]      [12]
   / \       / \       /  \

[2]   [4]   [6][8]    [11][14]

如果我们要删除 7， 那么，7的位置成为空键，不满足最小值1. 两个选择，向左右兄弟借键或者父键下沉合并。因为我们如果6 8 整体向上移动，那么叶子不在同一层级，不可以。所以我们可以选择5 或者10，在这里我们选择5 下沉，与3 合并成一个键。6，8继续作为叶子。保持了最小键数和叶子层数一致。

               [10]         
         /              \
      [3, 5]           [12]
   / / / \              /  \

[2][4][6][8]          [11][14]

### Degree

树的阶（或称为度数，通常表示为*t*）定义了节点的最小和最大子节点数。阶数*t*告诉我们：

我们假设t为2，（B树，每个节点最多三个键值）

- **最小键数**：每个非根节点必须至少包含*t*−1个键。这意味着它们至少是半满的。
    
- **最大键数**：每个节点最多可以包含2*t*−1个键。
    

根节点是个例外，它的键数可以少于*t*−1，但通常至少有一个键，除非树是空的。

## 2-3 tree （t = 3）

2-3树是一种自平衡搜索树，具有特定的结构和操作规则，确保了高效的数据查找、插入和删除操作。以下是2-3树的主要特性：

1. **节点结构**：
    - 每个节点可以包含1个或2个键（也被称为元素或数据项）。
    - 每个节点可以有2个、3个或没有子节点（叶子节点没有子节点）。
2. **键和子节点的关系**：
    - 一个包含单个键的节点有两个子节点（如果不是叶子节点）。
    - 一个包含两个键的节点有三个子节点（如果不是叶子节点）。
    - 子节点中存储的键总是小于其右侧父节点的键，大于其左侧父节点的键。
3. **树的平衡性**：
    - **所有叶子节点都位于同一层，这是2-3树的一个重要特征，**确保了从根到每个叶子的路径长度相同。
    - 树自动通过节点分裂和合并来维持平衡，无需额外的平衡操作，如AVL树或红黑树中所需的旋转。
4. **插入操作**：
    - 新键总是先在叶子节点中插入。
    - 如果一个叶子节点已经包含两个键（即满），则在插入新键后节点分裂成两个新节点，并将中间键推向父节点。
    - 如果父节点也满，则递归进行分裂，有时可能导致树高增加。
5. **删除操作**：
    - 当删除一个键后节点变得不满足最小填充要求时，**可以通过从兄弟节点借键或与兄弟节点合并来调整。**
    - 删除操作可能涉及多层的节点合并和键的重新分配，以确保所有节点至少包含一个键。
6. **搜索操作**：
    - 从根节点开始，根据键的大小向左或右递归搜索子

# B tree

B树是一种自平衡的树状数据结构，可以看作是2-3树概念的扩展，用于维护排序数据的高效访问和更新。B树在处理大量数据时特别有效，因为它们减少了磁盘I/O操作的次数，这是通过保持低树高并减少访问磁盘页面的需要来实现的。以下是B树的主要特性，从2-3树的基本特性扩展而来：

### **1. 节点最大和最小键数**

- B树的每个节点可以包含的键数量有一个上限（称为阶，或*t*）。对于一个阶为*t*的B树：
    - 每个节点最多可以有*t*−1个键（因此，它可以有最多*t*个子节点）。
    - 每个非根节点至少必须持有⌈*t*/2⌉−1个键 (对t/2 向上取整， 所以2-3 tree 中 t = 3，则 t/2 向上取整为2， 再 -1 为1)，但根节点可以例外，它至少可以有一个键。

### **2. 高度优化**

- 所有的叶子节点都位于同一层。B树通过在每个节点中存储多个键来减少树的高度，这对于在磁盘上高效管理大型数据库和文件系统索引非常有用。

### **3. 插入**

- 插入新键始终是在叶子节点进行。如果叶子节点已满（即已含有*t*−1个键），则在插入新键之前，节点会沿中间键分裂成两个新节点，并将中间键推送到父节点。
    
- 如果父节点也满，这种分裂会向上传播，可能会一直传播到根节点，从而使树高增加。

### **4. 删除**

- 当删除键可能导致节点键数少于最小键数时，节点可以从相邻兄弟节点借键或与一个兄弟节点合并。
- 删除操作也可能导致多层的节点合并和键的重新分配，以保持所有节点的最小键数。

一个例子

     [5,       10]
     /    |         \
   [3]    [7]      [12]
   / \    / \      /  \

[2]  [4][6]  [8]  [11] [14]

如果我们要删除 7， 那么，7的位置成为空键，不满足最小值1. 两个选择，向左右兄弟借键或者父键下沉合并。因为我们如果6 8 整体向上移动，那么叶子不在同一层级，不可以。所以我们可以选择5 或者10，在这里我们选择5 下沉，与3 合并成一个键。6，8继续作为叶子。保持了最小键数和叶子层数一致。

               [10]         
         /          \
      [3, 5]       [12]
   / /  / \        /  \

[2][4][6][8]     [11][14]

### **5. 搜索**

- 与2-3树类似，B树的搜索操作开始于根节点，根据键的大小递归向下移动至相应的子节点。
- B树通过减少必需的层级访问来优化搜索时间，这是通过在每个节点中保留更多的键来实现的。

### **6. 平衡**

- B树通过在每次插入或删除操作后维护其结构规则（如键的最小和最大数量，以及叶子节点的层级对齐）来保持平衡。
- 这种自平衡特性确保了在树中进行搜索、插入和删除操作的高效性。

B树因其优异的平衡性和低高度而被广泛用于数据库和操作系统的文件系统中，特别是在需要频繁读写大量数据的场合。通过在每个节点中存储多个键和减少树的高度，B树优化了对磁盘的访问次数，从而提高了操作效率。

B树的数据存储策略通常依赖于其应用场景，特别是在数据库管理系统和文件系统中的使用。B树设计的初衷之一就是优化磁盘I/O操作，以适应大数据量的处理需求。具体来说，数据在B树中的存储通常涉及内存和磁盘的联合使用，下面是详细的说明：

### **1. 磁盘存储**

- **主存储**：B树经常被用于数据库和文件系统中，这些应用要求大量数据的持久存储。在这些情况下，B树的节点数据主要存储在磁盘上。
- **优化设计**：B树的节点大小通常设计为与磁盘的页大小相匹配，这意味着每个节点的加载或保存操作通常对应一次磁盘I/O操作。这种设计减少了磁盘访问次数，因为一个节点内含多个键，可以在单次I/O中处理多个查询或更新操作。

### **2. 内存缓存**

- **性能提升**：尽管B树的数据主要存储在磁盘上，但为了提高性能，常常在内存中缓存频繁访问的节点。这种缓存机制可以极大地减少必须从磁盘读取数据的次数。
- **缓存策略**：数据库系统通常使用类似LRU（最近最少使用）等缓存替换策略来管理内存中的B树节点。这样，最常被访问的节点保持在内存中，而不经常访问的节点在需要空间时从缓存中移除，并在需要时重新从磁盘加载。

### **3. 读写操作**

- **读操作**：当执行读操作时，系统首先检查所需的B树节点是否已在内存缓存中。如果是，直接从内存读取；如果不是，从磁盘加载到内存中再进行操作。
- **写操作**：对B树的修改首先在内存中进行，随后通过一种叫做“写回”或“写入”策略在适当时将更改持久化到磁盘。这样可以批量处理对磁盘的写操作，优化性能。

总结来说，B树结合了内存的快速访问能力和磁盘的大容量存储，通过智能的缓存和数据同步策略，既保证了数据的持久性，又优化了访问效率。这种策略使得B树特别适合于处理大规模数据集，如数据库索引和文件系统目录，其中既需要高效的数据检索，也要求数据的安全和持久存储。