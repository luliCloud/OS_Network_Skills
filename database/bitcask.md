假设我们有一个初始为空的Bitcask数据库，我们开始向数据库中写入键值对。

第一步：写入数据
写入操作：假设我们写入了两个键值对，A:1 和 B:2。

活动日志文件：这两个键值对被顺序追加到当前的活动日志文件中（存在磁盘里，重启不会丢失）。例如，文件data1.log成为活动文件，里面现在有A:1和B:2。

键目录：内存中的键目录同时被更新，记录下A和B在data1.log文件中的位置和偏移量。
⚠️：键目录位于内存中。假设：
A:1\n
B:2\n
键A的位置信息是：文件标识符data1.log，偏移量0（文件开头）。
键B的位置信息是：文件标识符data1.log，偏移量10（假设\n换行符也占用一个字节）
当Bitcask需要读取键A的值时，它会查看内存中的键目录，找到A的位置信息，然后根据这些信息直接跳到data1.log文件的第0个字节处读取数据。对于键B，它会跳到第10个字节处开始读取。

第二步：继续写入
更多写入操作：接下来，我们又写入了两个键值对，C:3 和 A:4。注意，A:4是对A的更新。

活动日志文件更新：这些写入操作继续追加到data1.log（如果未达到文件大小限制）或者一个新的活动日志文件data2.log（如果data1.log已满）。

键目录更新：内存中的键目录更新，以反映新的键值对C:3和更新后的A:4的位置。对于A:4，键目录现在指向这个新值的位置，而不是旧值A:1。

第三步：读取数据
读取A的值：当请求读取键A的值时，Bitcask查看内存中的键目录，找到A最新的位置信息（指向A:4），然后从对应的日志文件（可能是data1.log或data2.log）中读取这个值。

第四步：压缩和合并
随着时间的推移，一些活动文件会被封闭，新的活动文件会被创建。Bitcask定期对这些文件进行压缩和合并，删除过期或被更新的键值对（如旧的A:1），只保留每个键的最新值。
在这个过程中，合并后的数据会被存储到新的数据文件中，旧的数据文件可以被删除。

关系总结
活动日志文件：是当前写入的目的地，记录了最新的写入操作。
键目录：在内存中维护每个键最新值的位置信息，无论是在活动文件还是在旧的数据文件中。
数据文件：存储了写入的键值对数据。随着活动文件的封闭和压缩合并操作，这些文件构成了数据库的持久存储。
通过这种设计，Bitcask能够快速写入和检索数据，同时优化存储空间的使用并简化崩溃恢复过程。

当系统重启时，内存中的内容（包括键目录）会丢失。为了解决这个问题，Bitcask采取了一些措施来在系统启动时重建键目录：

1. 读取日志文件：系统启动时，Bitcask会遍历存储在磁盘上的所有日志文件（包括活动日志文件和不活动的日志文件），读取这些文件中的数据条目，重建键与其在文件中位置的映射关系。这个过程是必要的，因为它确保了即使在系统崩溃后，也能够恢复内存中的键目录，并继续提供高效的读写服务。

2. 使用提示文件：为了加速启动时的键目录重建过程，Bitcask可能会使用“提示文件”（hint files）。提示文件包含了键和其在日志文件中位置的映射关系，读取提示文件比遍历整个日志文件更快，因为它们仅包含必要的元数据，而不是完整的数据条目。

通过这种机制，Bitcask确保了即使在重启后，也能够快速重建内存中的键目录，从而保持其快速访问数据的能力。活动日志文件和其他日志文件存储在磁盘上的设计，加上启动时对这些文件的处理流程，平衡了性能和数据持久性的需求。





